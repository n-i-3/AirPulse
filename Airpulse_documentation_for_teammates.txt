Structure in this exact order:

1. WHAT IT DOES (Features)
2. HOW WE BUILT IT (Tech Stack)
3. DEEP DIVE (Page-by-Page Implementation)


PART 1: KEY FEATURES (What makes this special?)
-----------------------------------------------
"AirPulse is an end-to-end Air Quality Command Center."

1. Real-Time Monitoring: We don't show old data. We show live, breathing data from thousands of sensors across Delhi NCR.
2. AI Forecasting: We don't just report the past. Our Edge AI model predicts the next 24 hours of air quality so citizens can plan their day.
3. Verified Citizen Reporting: We allow users to report pollution (like garbage burning). We use Cryptography to make these reports verifiable but anonymous.
4. Intelligent Analytics: We automatically analyze pollution sources (is it dust? is it traffic?) and generate health recommendations.


PART 2: THE TECH STACK (The Tools We Used)
------------------------------------------
"We used a modern, high-performance stack to ensure speed and scalability."

1. Frontend: Next.js 15
   - Used for: The User Interface.
   - Why: It's super fast because it renders pages on the server before sending them to the phone.

2. Backend: Node.js & Express
   - Used for: The "Brain" of the operation.
   - Why: It fetches data from external APIs, cleans it, and serves it to our app securely.

3. Database: MongoDB
   - Used for: Storing Reports and User Data.
   - Why: It's flexible and allows us to save complex data like location coordinates and pollution logs easily.

4. Authentication: Privy
   - Used for: Login and Wallets.
   - Why: It lets users login with just an email but gives them a powerful Crypto Wallet in the background.

5. AI Engine: TensorFlow & Math.js
   - Used for: Calculating predictions in the browser.


PART 3: PAGE-BY-PAGE DEEP DIVE (The "How It Works")
---------------------------------------------------

--- PAGE 1: THE DASHBOARD (Overview) ---
"This is the first thing functionality users see."

*   Feature: The Live Heatmap
    - How we built it: We use "Learflet.js" for the map interactions.
    - The Tech: The backend fetches raw GPS coordinates from the WAQI API. It converts them into a standardized JSON format. The Frontend then loops through this array and renders a <CircleMarker> for each station. The color (Red/Green) is determined dynamically by a javascript function checking the AQI value.

*   Feature: Real-Time Statistics
    - How we built it: The "Active Reporters" count isn't fake. It's a live count from our MongoDB database. Every time someone submits a report, this number increments instantly across the world.

--- PAGE 2: THE AI FORECAST PAGE ---
"This is where the magic happens."

*   Feature: The Prediction Chart
    - How we built it: We implemented a custom algorithm called "Harmonic Analysis" strictly on the Client Side.
    - The Tech: We take the current API reading. We apply a mathematical "Sine Wave" function to simulate the daily temperature drops (which cause pollution spikes at night). We combines this with the recent rate-of-change trend. 
    - Why this is cool: Because it runs in the browser, it works even if the internet is slow or offline for a moment.

*   Feature: Ward Selection
    - How we built it: We mapped the exact Latitude/Longitude boundaries of major wards (like Rohini, Dwarka) in our backend.
    - The Tech: When you select a ward, the Node.js server filters the thousands of sensors to find only the ones inside that specific rectangle and calculates a "Weighted Average" for accuracy.

--- PAGE 3: THE REPORT PAGE ---
"This is our Citizen Science layer."

*   Feature: "Connect Wallet" / Login
    - How we built it: We strictly used the "Privy SDK".
    - The Tech: When a user logs in, Privy creates an "Embedded Wallet" inside the app. We verify this wallet is active before allowing them to open the camera.

*   Feature: Secure Evidence Submission
    - How we built it: We treat every report like a financial transaction.
    - The Tech: When the form is submitted, we take the User ID and specific Timestamp. We run it through a "SHA-256 Hashing Algorithm". This generates a unique digital fingerprint for that exact report. We save this fingerprint in MongoDB. This ensures that no one can fake or duplicate reports later.

--- PAGE 4: THE SOURCES PAGE ---
"This helps officials know WHAT to fix."

*   Feature: Source Identification
    - How we built it: Pure Backend Logic.
    - The Tech: The server compares different pollutant values (PM2.5 vs PM10 vs NO2).
    - The Logic: If NO2 is high, the code flags it as "Traffic Pollution". If PM10 is high, it flags "Construction Dust". This logic runs automatically on every data update.

--- PAGE 5: INTELLIGENCE FEED ---
"The automated news anchor."

*   Feature: Auto-Generated Alerts
    - How we built it: Server-Side Polling.
    - The Tech: A background job runs every 5 minutes on the server. It scans the database for any station exceeding 300 AQI. If found, it creates a new "Alert Object" and pushes it to the frontend via the API